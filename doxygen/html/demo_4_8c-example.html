<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>cr_lib: demo_4.c</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<h1>demo_4.c</h1>  </div>
</div>
<div class="contents">
<div class="fragment"><pre class="fragment">
<span class="preprocessor">#include &lt;pthread.h&gt;</span>
<span class="preprocessor">#include &lt;stdio.h&gt;</span>
<span class="preprocessor">#include &lt;stdlib.h&gt;</span>
<span class="preprocessor">#include &lt;signal.h&gt;</span>
<span class="preprocessor">#include &lt;sched.h&gt;</span>
<span class="preprocessor">#include &lt;limits.h&gt;</span>


<span class="preprocessor">#include &quot;<a class="code" href="cr_8h.html">cr.h</a>&quot;</span>

<span class="keyword">static</span> <span class="keywordtype">void</span> Thread_A(<span class="keywordtype">void</span>);
<span class="keyword">static</span> <span class="keywordtype">void</span> Thread_B(<span class="keywordtype">void</span>);
<span class="keyword">static</span> <span class="keywordtype">void</span> Thread_C(<span class="keywordtype">void</span>);
<span class="keyword">static</span> <span class="keywordtype">void</span> Thread_D(<span class="keywordtype">void</span>);
<span class="keyword">static</span> <span class="keywordtype">void</span> cleanup(<span class="keywordtype">void</span>);
<span class="keyword">static</span> <span class="keywordtype">void</span> signal_handler(<span class="keywordtype">int</span> signal);
<span class="keyword">static</span> <span class="keywordtype">void</span>* isr_thread(<span class="keywordtype">void</span>* args);

<span class="comment">//--------------- Some simulated ISR thread objects</span>
<span class="keyword">struct </span><a name="_a0"></a><a class="code" href="structsched__param.html">sched_param</a>          isr_thread_sched;
pthread_attr_t              isr_thread_attr;
int32_t                     isr_thread_run  = <span class="keyword">false</span>;

<span class="preprocessor">#ifdef _MSC_VER</span>
<span class="preprocessor"></span>    <a name="_a1"></a><a class="code" href="structptw32__handle__t.html">pthread_t</a>                   isr_thread_id   = { 0, 0 };
<span class="preprocessor">#else</span>
<span class="preprocessor"></span>    <a class="code" href="structptw32__handle__t.html">pthread_t</a>                   isr_thread_id   = 0;
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>
<span class="comment">// Our simulated ISR thread</span>
<span class="keywordtype">void</span>* isr_thread( <span class="keywordtype">void</span>* args )
{
    <span class="keyword">static</span> cr_uint32_t     cnt = 0;

    <span class="keywordflow">while</span> ( isr_thread_run ) {
        cnt = 0;

        <span class="comment">// we want to simulate an external event</span>
        <span class="comment">// wait long enough so that all 4 coroutines have time to complete</span>
        <span class="keywordflow">while</span> ( cnt &lt; 100000 ) {
            ++cnt;
        }

        printf( <span class="stringliteral">&quot;----------- ISR Posting ----------\n&quot;</span> );

        <span class="comment">// Set the thread activate flag, in this case it&#39;s Thread_A.</span>
        <span class="comment">// cr_g_activate_id is an exported object. cr_idle spins</span>
        <span class="comment">// on this object, provided cr_idle is explicitly called by</span>
        <span class="comment">// the user, waiting for it to change from CR_IDLE_THREAD_ID.</span>
        <span class="comment">// The changed-value is the ID of the coroutine to be called.</span>
        assert( Thread_A &amp;&amp; <span class="stringliteral">&quot;isr_thread: Thread_A pointer is invalid!&quot;</span> );
        <a name="a2"></a><a class="code" href="cr_8c.html#a1345c6db4d2d1d939e7841da46704d8e" title="Holds the ID of the coroutine to be activated - by cr_idle.">cr_g_activate_id</a> = <a name="a3"></a><a class="code" href="cr_8c.html#a3e7a31163658d81c9473e5b637d9eb90" title="Find the ID of a coroutine.">cr_get_id</a>( Thread_A );

        assert( ( <a class="code" href="cr_8c.html#a1345c6db4d2d1d939e7841da46704d8e" title="Holds the ID of the coroutine to be activated - by cr_idle.">cr_g_activate_id</a> != <a name="a4"></a><a class="code" href="cr_8h.html#adf764cbdea00d65edcd07bb9953ad2b7acd063e5de520275d94952e07b5f29b18">CR_INVALID_ID</a> ) &amp;&amp; <span class="stringliteral">&quot;isr_thread: cr_get_id returned CR_INVALID_ID!&quot;</span> );
    }

    printf( <span class="stringliteral">&quot;isr_thread exiting...\n&quot;</span> );

    <span class="keywordflow">return</span> 0;
}

<span class="keywordtype">void</span> Thread_A( <span class="keywordtype">void</span> )
{
    <span class="comment">// A. locals use the &#39;volatile&#39; qualifier</span>
    cr_int32_t      i;
    cr_uint32_t     cnt = 0;

    <span class="comment">// B. the required init call</span>
    <a name="a5"></a><a class="code" href="cr_8h.html#ac68ef77f5ea5f5dda5a2f046a2c96429" title="Initializes a function as a coroutine.">CR_THREAD_INIT</a>( );

    <span class="keywordflow">while</span> ( <span class="keyword">true</span> ) {
        i = 1000;

        <span class="keywordflow">while</span>( i-- ) {
            cnt += 1;
        }

        printf( <span class="stringliteral">&quot;- Thread_A yielding to Thread_B\n&quot;</span> );
        assert( Thread_B &amp;&amp; <span class="stringliteral">&quot;Thread_A: Thread_B pointer is invalid!&quot;</span>) ;

        <span class="comment">// C. coroutine yield - to Thread_B</span>
        <a name="a6"></a><a class="code" href="cr_8h.html#a18adb578c9437579bc39134852d4fc5b" title="Explicitly yields to a coroutine.">CR_YIELD</a>( Thread_B );
    }
}

<span class="keywordtype">void</span> Thread_B( <span class="keywordtype">void</span> )
{
    <span class="comment">// A. locals use the &#39;volatile&#39; qualifier</span>
    cr_int32_t      i;
    cr_uint32_t     cnt = 0;

    <span class="comment">// B. the required init call</span>
    <a class="code" href="cr_8h.html#ac68ef77f5ea5f5dda5a2f046a2c96429" title="Initializes a function as a coroutine.">CR_THREAD_INIT</a>( );

    <span class="keywordflow">while</span> ( <span class="keyword">true</span> ) {
        i = 1000;

        <span class="keywordflow">while</span> ( i-- ) {
            cnt += 1;
        }

        printf( <span class="stringliteral">&quot;- Thread_B yielding to Thread_C\n&quot;</span> );
        assert( Thread_C &amp;&amp; <span class="stringliteral">&quot;Thread_B: Thread_C pointer is invalid!&quot;</span> );

        <span class="comment">// C. explicitly yield - to Thread_C</span>
        <a class="code" href="cr_8h.html#a18adb578c9437579bc39134852d4fc5b" title="Explicitly yields to a coroutine.">CR_YIELD</a>( Thread_C );
    }
}

<span class="keywordtype">void</span> Thread_C( <span class="keywordtype">void</span> )
{
    <span class="comment">// A. locals use the &#39;volatile&#39; qualifier</span>
    cr_int32_t      i;
    cr_uint32_t     cnt = 0;

    <span class="comment">// B. the required init call</span>
    <a class="code" href="cr_8h.html#ac68ef77f5ea5f5dda5a2f046a2c96429" title="Initializes a function as a coroutine.">CR_THREAD_INIT</a>( );

    <span class="keywordflow">while</span> ( <span class="keyword">true</span> ) {
        i = 1000;

        <span class="keywordflow">while</span> ( i-- ) {
            cnt += 1;
        }

        printf( <span class="stringliteral">&quot;- Thread_C yielding to Thread_D\n&quot;</span> );
        assert( Thread_D &amp;&amp; <span class="stringliteral">&quot;Thread_C: Thread_D pointer is invalid!&quot;</span> );

        <span class="comment">// C. explicitly yield - to Thread_D</span>
        <a class="code" href="cr_8h.html#a18adb578c9437579bc39134852d4fc5b" title="Explicitly yields to a coroutine.">CR_YIELD</a>( Thread_D );
    }
}

<span class="keywordtype">void</span> Thread_D( <span class="keywordtype">void</span> )
{
    <span class="comment">// A. locals use the &#39;volatile&#39; qualifier</span>
    cr_int32_t      i;
    cr_uint32_t     cnt = 0;

    <span class="comment">// B. the required init call</span>
    <a class="code" href="cr_8h.html#ac68ef77f5ea5f5dda5a2f046a2c96429" title="Initializes a function as a coroutine.">CR_THREAD_INIT</a>( );

    <span class="keywordflow">while</span> ( <span class="keyword">true</span> ) {
        i = 1000;

        <span class="keywordflow">while</span> ( i-- ) {
            cnt += 1;
        }

        printf( <span class="stringliteral">&quot;- Thread_D yielding to Thread_A\n&quot;</span> );
        assert( <a name="a7"></a><a class="code" href="cr_8c.html#accd73b48023970380bfdecb56483976c" title="The internal system&amp;#39;s coroutine thread.">cr_idle</a> &amp;&amp; <span class="stringliteral">&quot;Thread_D: cr_idle pointer is invalid!&quot;</span> );

        <span class="comment">// C. explicitly yield - to cr_idle</span>
        <a class="code" href="cr_8h.html#a18adb578c9437579bc39134852d4fc5b" title="Explicitly yields to a coroutine.">CR_YIELD</a>( <a class="code" href="cr_8c.html#accd73b48023970380bfdecb56483976c" title="The internal system&amp;#39;s coroutine thread.">cr_idle</a> );
    }
}

<span class="keywordtype">void</span> signal_handler( <span class="keywordtype">int</span> signal )
{
    <span class="keywordflow">switch</span>( signal ) {
        <span class="keywordflow">case</span> SIGFPE:
            perror( <span class="stringliteral">&quot;A floating point exception occured.\n&quot;</span> );
            <span class="keywordflow">break</span>;
        <span class="keywordflow">case</span> SIGILL:
            perror( <span class="stringliteral">&quot;An illegal instruction occured.\n&quot;</span> );
            <span class="keywordflow">break</span>;
        <span class="keywordflow">case</span> SIGINT:
            <span class="comment">// user hit CTRL-C</span>
            <span class="keywordflow">break</span>;
        <span class="keywordflow">case</span> SIGSEGV:
            perror( <span class="stringliteral">&quot;A segmentation violation occured.\n&quot;</span> );
            <span class="keywordflow">break</span>;
        <span class="keywordflow">default</span>:
            perror( <span class="stringliteral">&quot;An unknown signal was caught.\n&quot;</span> );
            <span class="keywordflow">break</span>;
    }

    <span class="comment">// Pass EXIT_SUCCESS the registered atexit function handler gets called</span>
    exit( EXIT_SUCCESS );
}

<span class="keywordtype">void</span> cleanup( <span class="keywordtype">void</span> )
{
    uint32_t <span class="keyword">volatile</span> timing_barrier  = 0;

    <span class="comment">// kindly kill our simulated ISR thread</span>
    isr_thread_run = <span class="keyword">false</span>;

    timing_barrier = 800000;

    <span class="comment">// Code block to stop the compiler from messing with the code</span>
    {
        <span class="keywordflow">while</span>( timing_barrier-- )
            <span class="comment">/* no code */</span> ;
    }

    <a name="a8"></a><a class="code" href="cr_8c.html#a3e8d6963f6ee2cc49502186eca21d879" title="Resets the system to an initial state.">cr_reset</a>( );

<span class="comment">//    pthread_exit( 0 );</span>
    printf( <span class="stringliteral">&quot;    Exiting...\n&quot;</span>  );
}

<span class="comment">// 4 user threads plus 1 the system&#39;s idle thread</span>
<span class="preprocessor">#define CONTEXT_ARRAY_CNT ( 4 + 1 )</span>
<span class="preprocessor"></span>
<span class="keywordtype">int</span> main( <span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>* argv[] )
{
    uint32_t            tmp             = 0;
    uint32_t <span class="keyword">volatile</span>   timing_barrier  = 0;

    <span class="comment">// we explicitly create the array of CR_CONTEXT structures</span>
    <a name="_a9"></a><a class="code" href="struct_c_r___c_o_n_t_e_x_t.html" title="Coroutine context information.">CR_CONTEXT</a> context_array[CONTEXT_ARRAY_CNT];

    <span class="comment">// register a cleanup function</span>
    atexit( cleanup );

    <span class="comment">// some signal handlers</span>
    <span class="keywordflow">if</span> ( signal( SIGFPE, signal_handler ) == SIG_ERR ) {
        perror( <span class="stringliteral">&quot;An error occured while setting the SIGFPE signal handler.\n&quot;</span> );
    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( signal( SIGILL, signal_handler ) == SIG_ERR ) {
        perror( <span class="stringliteral">&quot;An error occured while setting the SIGILL signal handler.\n&quot;</span> );
    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( signal( SIGINT, signal_handler ) == SIG_ERR ) {
        perror( <span class="stringliteral">&quot;An error occured while setting the SIGINT signal handler.\n&quot;</span> );
    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( signal( SIGSEGV, signal_handler ) == SIG_ERR ) {
        perror( <span class="stringliteral">&quot;An error occured while setting the SIGSEGV signal handler.\n&quot;</span> );
    }

    <span class="comment">// 1. init the cr library</span>
    assert( ( ( <span class="keyword">sizeof</span>( context_array ) / <span class="keyword">sizeof</span>( <a class="code" href="struct_c_r___c_o_n_t_e_x_t.html" title="Coroutine context information.">CR_CONTEXT</a> ) ) == CONTEXT_ARRAY_CNT )
                                        &amp;&amp; <span class="stringliteral">&quot;context_array size mismatch!\n&quot;</span> );

    <a name="a10"></a><a class="code" href="cr_8c.html#aca6b87323f9ce0bf21b3f06209a97989" title="cr_lib&amp;#39;s initialization function.">cr_init</a>( context_array, CONTEXT_ARRAY_CNT );

    <span class="comment">// 2. register the threads</span>
    <a name="a11"></a><a class="code" href="cr_8c.html#ae30bdb4ef569c0678e4cb49829f11bbb" title="Register a function as a coroutine thread.">cr_register_thread</a>( Thread_A );
    <a class="code" href="cr_8c.html#ae30bdb4ef569c0678e4cb49829f11bbb" title="Register a function as a coroutine thread.">cr_register_thread</a>( Thread_B );
    <a class="code" href="cr_8c.html#ae30bdb4ef569c0678e4cb49829f11bbb" title="Register a function as a coroutine thread.">cr_register_thread</a>( Thread_C );
    <a class="code" href="cr_8c.html#ae30bdb4ef569c0678e4cb49829f11bbb" title="Register a function as a coroutine thread.">cr_register_thread</a>( Thread_D );

    <span class="comment">//--------------------------------------------------------------------------</span>
    <span class="comment">//-------------------- Simulated ISR Thread Setup --------------------------</span>
    pthread_attr_init( &amp;isr_thread_attr );

    pthread_attr_setschedpolicy( &amp;isr_thread_attr,
                                 SCHED_RR );

    pthread_attr_setstacksize( &amp;isr_thread_attr,
                               PTHREAD_STACK_MIN );

<span class="comment">// XXX: the scheduling priority could be set here</span>

    pthread_attr_setschedparam( &amp;isr_thread_attr,
                                &amp;isr_thread_sched );

    isr_thread_run = <span class="keyword">true</span>;

    tmp = pthread_create( &amp;isr_thread_id,
                          &amp;isr_thread_attr,
                          isr_thread,
                          0 );

    assert( ( tmp == 0 ) &amp;&amp; <span class="stringliteral">&quot;pthread_create failed!&quot;</span> );

    timing_barrier = 1000;

    <span class="comment">// Code block to stop the compiler from messing with the code</span>
    {
        <span class="keywordflow">while</span>( timing_barrier-- )
            <span class="comment">/* no code */</span> ;
    }
    <span class="comment">//--------------------------------------------------------------------------</span>

    <span class="comment">// 3. bootstrap the system</span>
    <a name="a12"></a><a class="code" href="cr_8h.html#ad89b832374912ca6c097b550a95a8ebf" title="Starts the cr_lib system.">CR_START</a>( <a class="code" href="cr_8c.html#accd73b48023970380bfdecb56483976c" title="The internal system&amp;#39;s coroutine thread.">cr_idle</a> );

    <span class="keywordflow">return</span> EXIT_SUCCESS;
}
</pre></div> </div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Fri Jun 25 2010 09:38:58 for cr_lib by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
