<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>cr_lib: Main Page</title>
<link href="tabs.css" rel="stylesheet" type="text/css">
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.8 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li class="current"><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>cr_lib Documentation</h1>
<p>
<h3 align="center">v1.0 </h3>cr_lib is a simple, portable, cooperative multitasking environment using coroutines. It features a mechanism for exiting and re-entering a function in a non-standard way using the standard C library's setjmp and longjmp functions. Coroutine threads run one at a time where each thread must be explicitly scheduled. cr_lib does include a system coroutine, cr_idle, that can be used in conjunction with the variable cr_g_activate_id to activate a coroutine. cr_g_activate_id could be used, for example, in an ISR routine of an event driven system. <br>
<p>
cr_lib is probably most useful for micro-controllers, DSPs, small GPPs, or educational purposes.<p>
<b> What is a coroutine: </b> <br>
<p>
"A coroutine is represented by a closure (a code address and a referencing environment), into which we can jump by means of a nonlocal goto - in this case a special operation known as a transfer. In effect, coroutines are execution contexts that exist concurrently but execute one at a time, and transfer control to each other explicitly by name." From <em> Programming Language Pragmatics by Morgan Kaufmann </em> <br>
<p>
<b> Using cr_lib </b><ul>
<li>Initialize cr_lib by calling "cr_init" with the appropriate paramters</li><li>Create a coroutine by calling "cr_register_thread"</li><li>Call "CR_START" with the name of the coroutine to bootstrap the system</li><li>Call "CR_THREAD_INIT" at the start of each coroutine thread</li><li>Call "CR_YIELD" at the desired points within coroutine thread</li></ul>
<p>
<div class="fragment"><pre class="fragment">    example of initialization, registration, and start of cr_lib
    ------------------------------------------------------------

<span class="preprocessor">    #define CONTEXT_ARRAY_CNT   (2 + 1)</span>
<span class="preprocessor"></span>
    <a class="code" href="struct_c_r___c_o_n_t_e_x_t.html" title="Coroutine context information.">CR_CONTEXT</a> context_array[CONTEXT_ARRAY_CNT];

    <span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>* argv[])
    {
        <span class="comment">// 1. initialize cr_lib</span>
        <a class="code" href="cr_8c.html#ca6b87323f9ce0bf21b3f06209a97989" title="cr_lib&amp;#39;s initialization function.">cr_init</a>(context_array, CONTEXT_ARRAY_CNT);

        <span class="comment">// 2. register functions</span>
        <a class="code" href="cr_8c.html#e30bdb4ef569c0678e4cb49829f11bbb" title="Register a function as a coroutine thread.">cr_register_thread</a>(Thread_A);
        <a class="code" href="cr_8c.html#e30bdb4ef569c0678e4cb49829f11bbb" title="Register a function as a coroutine thread.">cr_register_thread</a>(Thread_B);

        <span class="comment">// 3. bootstrap system</span>
        <a class="code" href="cr_8h.html#d89b832374912ca6c097b550a95a8ebf" title="Starts the cr_lib system.">CR_START</a>(Thread_A);

        <span class="keywordflow">return</span> 0;
    }

         coroutine 1                                     coroutine 2
         -----------                                     -----------
    <span class="keywordtype">void</span> Thread_A(<span class="keywordtype">void</span>)                            void Thread_B(<span class="keywordtype">void</span>)
    {                                               {
        <a class="code" href="cr_8h.html#c68ef77f5ea5f5dda5a2f046a2c96429" title="Initializes a function as a coroutine.">CR_THREAD_INIT</a>();                               <a class="code" href="cr_8h.html#c68ef77f5ea5f5dda5a2f046a2c96429" title="Initializes a function as a coroutine.">CR_THREAD_INIT</a>();

        <span class="keywordflow">for</span>(;;)                                         <span class="keywordflow">while</span>(1)
        {                                               {
            <span class="comment">// main body of code                             // main body of code</span>
            <a class="code" href="cr_8h.html#18adb578c9437579bc39134852d4fc5b" title="Explicitly yields to a coroutine.">CR_YIELD</a>(Thread_B);                              <a class="code" href="cr_8h.html#18adb578c9437579bc39134852d4fc5b" title="Explicitly yields to a coroutine.">CR_YIELD</a>(<a class="code" href="cr_8c.html#ccd73b48023970380bfdecb56483976c" title="A system coroutine thread.">cr_idle</a>);

            <span class="comment">// user code                                     // user code</span>
        }                                               }
    }                                               }
</pre></div><p>
<b> Misc. Notes </b><p>
<ul>
<li>cr_init's cr_context parameter requires 1 extra element for the system's "cr_idle" coroutine. Therefore, set the cr_context_count equal to the number of coroutine threads plus one.</li></ul>
<p>
<ul>
<li>"cr_init" must be called before registering any coroutine threads</li></ul>
<p>
<ul>
<li>Coroutine thread's must take a "void" parameter and return "void."</li></ul>
<p>
<ul>
<li>A coroutine thread must call "CR_THREAD_INIT" at the top of the function before calling "CR_YIELD".</li></ul>
<p>
<ul>
<li>Register a coroutine thread using "cr_register_thread" where the coroutine thread's name is passed as a parameter.</li></ul>
<p>
<ul>
<li>Once all the coroutine threads are registered call "CR_START" with either a user coroutine thread name or the cr_idle coroutine name.</li></ul>
<p>
<ul>
<li>"cr_init" takes a user declared array of "CR_CONTEXT" and its element count plus 1. There needs to be an extra element reserved for the "cr_idle" coroutine.</li></ul>
<p>
<ul>
<li>Functions registered as coroutine threads should not return. I.e. the body of the main part of the code should be wrapped in an endless "for" or "while" loop.</li></ul>
<p>
<ul>
<li>The global variable "cr_g_activate_id" can be used to activate a coroutine by setting it to a coroutine's ID. For it to work the idle coroutine (cr_idle) must be yielded to explicitly at some point. Have a look at the demo_2 and demo_4 files. Each simulates an ISR type of external event. Be careful when scheduling events using "cr_g_activate_id"; there's no buffering of the coroutine ID's being assigned. Use "cr_get_id()" - passing a coroutine function name - to determine the ID of a coroutine. </li></ul>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Tue Jun 16 13:16:00 2009 for cr_lib by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.8 </small></address>
</body>
</html>
